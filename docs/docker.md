# Docker

Contents

1. Overview  
2. Prerequisites  
3. Build artifacts  
4. Building the rootfs tarball  
5. Importing into Docker  
6. Running a container  
7. Using a Dockerfile (FROM scratch)  
8. Architecture and platform notes  
9. Updating and rebuilding  
10. Troubleshooting  
11. See also  

---

## 1. Overview

This document explains how to use the generated root filesystem (rootfs) with Docker.  
The recommended entry point is the `make docker` target, which creates a rootfs tarball
and delegates to a helper script to import and tag it. You can also import and run the tarball
manually using standard Docker commands.

---

## 2. Prerequisites

- Docker installed and running:  
  - Linux: Docker Engine  
  - macOS / Windows: Docker Desktop  
- Sufficient permissions to access the Docker daemon (your user must be able to run `docker info`).

Verification:

```sh
docker --version
docker info
```

If either command fails, fix your Docker installation before proceeding.

---

## 3. Build artifacts

The Docker workflow uses the rootfs tarball generated by the build system:

```
build/<ARCH>/openlinux-<VERSION>-<ARCH>-rootfs.tar.gz
```

Where:

- `<ARCH>` is your chosen target (e.g. `x86_64`, `aarch64`)
- `<VERSION>` is defined in the top-level makefile (e.g. `1.0.0-alpha`)

Ensure you have already run the appropriate build targets (see `build.md`).

---

## 4. Building the rootfs tarball

The rootfs tarball contains the filesystem tree that will become the container’s root.

Build everything and create the rootfs:

```sh
make rootfs
```

Notes:

- On macOS, GNU tar (`gtar`) is auto-selected.
- The tarball is created with numeric ownership (UID/GID 0) and no extended attributes for portability.
- If you change included binaries/libraries, re-run `make` (or specific targets) before regenerating the tarball.

---

## 5. Importing into Docker

There are two common ways to turn the tarball into an image.

### Option 1: Using the provided make target

```sh
make docker
# Internally: sh tools/docker.sh $(ARCH) build/<ARCH>/openlinux-<VERSION>-<ARCH>-rootfs.tar.gz
```

Inspect `tools/docker.sh` for the exact import/tag flow.

### Option 2: Manual import

```sh
export ARCH=x86_64
export VERSION=1.0.0-alpha
export ROOTFS=build/${ARCH}/openlinux-${VERSION}-${ARCH}-rootfs.tar.gz

docker import "${ROOTFS}" "openlinux:${VERSION}-${ARCH}"
```

You can use any repository/tag naming scheme that fits your workflow (e.g., include a git commit).

List images to confirm:

```sh
docker images | grep openlinux
```

---

## 6. Running a container

Run an interactive shell:

```sh
docker run --rm -it --name openlinux-dev openlinux:1.0.0-alpha-x86_64 /bin/sh
```

If you want to explore the filesystem:

```sh
docker run --rm -it openlinux:1.0.0-alpha-x86_64 ls -l / /bin /usr/bin
```

Set a minimal environment:

```sh
docker run --rm -it -e PATH=/bin:/usr/bin openlinux:1.0.0-alpha-x86_64 /bin/sh
```

Bind-mount a working directory:

```sh
docker run --rm -it -v "$PWD":/work -w /work openlinux:1.0.0-alpha-x86_64 /bin/sh
```

General notes:

- Choose an entrypoint that exists (`/bin/sh`, `/bin/init`, or a custom binary).
- Minimal rootfs builds may lack common configuration files (`/etc/passwd`, etc.). Add what you need through the build system if required.

---

## 7. Using a Dockerfile (FROM scratch)

Instead of `docker import`, you can construct an image with a Dockerfile:

Example `Dockerfile`:

```Dockerfile
FROM scratch
ADD openlinux-1.0.0-alpha-x86_64-rootfs.tar.gz /
ENV PATH=/bin:/usr/bin
CMD ["/bin/sh"]
```

Build and tag:

```sh
cp build/x86_64/openlinux-1.0.0-alpha-x86_64-rootfs.tar.gz .
docker build -t openlinux:1.0.0-alpha-x86_64 .
```

Run:

```sh
docker run --rm -it openlinux:1.0.0-alpha-x86_64
```

Advantages:

- Reproducible build context
- Ability to add metadata (`LABEL`), environment variables, or copy in additional assets pre-container startup.

---

## 8. Architecture and platform notes

- Docker containers use the host kernel. Your userland must be ABI-compatible with the host architecture.
- Cross-architecture execution (e.g. running `aarch64` image on `x86_64` host) generally requires:
  - binfmt_misc configuration
  - User-mode emulation (e.g. `qemu-user-static`)
- Hint the desired platform:

```sh
docker run --platform=linux/arm64 --rm -it openlinux:1.0.0-alpha-aarch64 /bin/sh
```

Apple Silicon (ARM64):

- Prefer building/running native ARM64 images for performance.
- Emulation of `x86_64` images is possible but slower and requires proper binfmt/QEMU setup.

---

## 9. Updating and rebuilding

Iterative workflow:

```sh
# Rebuild libraries/binaries/sysroot
make -j8

# Re-create rootfs tarball
make rootfs

# Re-import with updated tag (or overwrite)
docker import build/<ARCH>/openlinux-<VERSION>-<ARCH>-rootfs.tar.gz openlinux:<VERSION>-<ARCH>
```

For traceability, consider tagging with commit hash or timestamp:

```sh
docker import build/${ARCH}/openlinux-${VERSION}-${ARCH}-rootfs.tar.gz \
  openlinux:${VERSION}-${ARCH}-$(git rev-parse --short HEAD)
```

Or with a timestamp:

```sh
docker import build/${ARCH}/openlinux-${VERSION}-${ARCH}-rootfs.tar.gz \
  openlinux:${VERSION}-${ARCH}-$(date +%Y%m%d-%H%M%S)
```

---

## 10. Troubleshooting

| Symptom | Cause | Fix |
|---------|-------|-----|
| `docker run` fails with “file not found” for `/bin/sh` | Shell not in rootfs | Add a shell binary during build or change the entrypoint |
| `docker import` fails | Wrong path or corrupt tarball | Re-run `make rootfs`; check path and file permissions |
| Architecture mismatch (ELF error) | Imported image for different arch without emulation | Use matching architecture or set up binfmt/qemu-user-static |
| Minimal environment causing tool failures | Missing `/etc` config, limited PATH | Set `PATH`, extend rootfs, or mount host directories |
| Permissions/connection errors | Docker daemon not reachable | Start Docker service, verify group membership (`docker info`) |
| Image not listed | Tag mismatch | Run `docker images` and re-import with consistent tagging |

Additional checks:

- Validate tarball contents before import:

  ```sh
  tar -tzf build/<ARCH>/openlinux-<VERSION>-<ARCH>-rootfs.tar.gz | head
  ```

- Inspect image after import:

  ```sh
  docker run --rm -it openlinux:<VERSION>-<ARCH> ls /
  ```

---

## 11. See also

- Build system details: `build.md`  
- Boot process and kernel command line: `boot.md`  
- Running in virtualized hardware (QEMU): `qemu.md`  

---

## 12. Reference summary (quick commands)

```sh
# Build everything and rootfs tarball
make rootfs

# Import manually
docker import build/x86_64/openlinux-1.0.0-alpha-x86_64-rootfs.tar.gz openlinux:1.0.0-alpha-x86_64

# Run interactive shell
docker run --rm -it openlinux:1.0.0-alpha-x86_64 /bin/sh

# Build FROM scratch via Dockerfile
cp build/x86_64/openlinux-1.0.0-alpha-x86_64-rootfs.tar.gz .
docker build -t openlinux:1.0.0-alpha-x86_64 .

# List local images
docker images | grep openlinux
```

---

## 13. Notes on extending the rootfs

If you need additional tooling inside the container:

1. Add source or library under the appropriate `bin/` or `lib/` directory in the project.
2. Include it in the build by updating `config` (see `build.md`).
3. Re-run `make` and then `make rootfs`.
4. Re-import the updated tarball.

For reproducibility, automate tagging and exporting with a script that records:
- Git commit
- Build timestamp
- Architecture
- Version

---

## 14. Security considerations

- `FROM scratch` images are minimal—no package manager, fewer attack surfaces.
- Ensure any binaries included are statically linked and vetted.
- Consider embedding a software bill of materials (SBOM) externally if needed.

---

## 15. FAQ

Q: Why use `docker import` instead of a Dockerfile?  
A: `docker import` is fast and direct for raw rootfs tarballs. A Dockerfile provides more metadata and reproducibility. Choose based on workflow needs.

Q: Can I layer additional files after importing?  
A: Yes. You can start from the imported image and create a new Dockerfile `FROM openlinux:<tag>` adding more content.

Q: Does the rootfs include kernel modules?  
A: The container uses the host kernel; modules must exist on the host, not inside the image.

Q: How do I add a shell if missing?  
A: Include a shell binary (e.g. BusyBox) in the build system, rebuild, regenerate rootfs, re-import.

---
