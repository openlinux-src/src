DOCKER
======

Contents
--------

1. Overview
2. Prerequisites
3. Build artifacts
4. Building the rootfs tarball
5. Importing into Docker
6. Running a container
7. Using a Dockerfile (FROM scratch)
8. Architecture and platform notes
9. Updating and rebuilding
10. Troubleshooting
11. See also

Overview
--------

This document explains how to use the generated root filesystem (rootfs) with Docker.
The recommended entry point is the `docker` make target, which creates a rootfs tarball
and delegates to a helper script to import/tag it. You can also import and run the tarball
manually using standard Docker commands.

Prerequisites
-------------

- Docker installed and running:
  - Linux: Docker Engine
  - macOS/Windows: Docker Desktop
- Sufficient permissions to access the Docker daemon.

Verification:

::

  docker --version
  docker info

Build artifacts
---------------

The Docker workflow uses the rootfs tarball generated by the build system:

- Rootfs tarball:
  ``build/<ARCH>/openlinux-<VERSION>-<ARCH>-rootfs.tar.gz``

Where:

- ``<ARCH>`` is your chosen target (e.g., ``x86_64``, ``aarch64``)
- ``<VERSION>`` is defined in the top-level makefile (e.g., ``1.0.0-alpha``)

Building the rootfs tarball
---------------------------

The rootfs tarball contains the filesystem tree that will become the container’s root.

- Build everything and create the rootfs tarball:

  ::

    make rootfs

Notes:

- On macOS, the build system uses GNU tar (`gtar`) automatically.
- The tarball is created with numeric ownership (UID/GID 0) and with extended attributes
  disabled to ensure compatibility with container import.

Importing into Docker
---------------------

There are two common ways to turn the tarball into a Docker image:

1) Use the provided `docker` make target:

::

  make docker
  # Internally: sh tools/docker.sh $(ARCH) build/<ARCH>/openlinux-<VERSION>-<ARCH>-rootfs.tar.gz

- Inspect `tools/docker.sh` to see the exact import/tagging behavior.

2) Import manually with `docker import`:

::

  # Example tag:
  export ARCH=x86_64
  export VERSION=1.0.0-alpha
  export ROOTFS=build/${ARCH}/openlinux-${VERSION}-${ARCH}-rootfs.tar.gz

  # Import and tag as openlinux:<version>-<arch>
  docker import "${ROOTFS}" "openlinux:${VERSION}-${ARCH}"

- You can choose any repository/tag naming scheme that fits your workflow.

Running a container
-------------------

Run an interactive container using the imported image:

::

  docker run --rm -it --name openlinux-dev openlinux:1.0.0-alpha-x86_64 /bin/sh

Notes:

- Entry point: Use a binary that exists in your rootfs (e.g., `/bin/sh`, `/bin/init`, or a
  custom tool under `/bin` or `/usr/bin`).
- If unsure what’s available, start with a simple command and inspect the filesystem:

  ::

    docker run --rm -it openlinux:1.0.0-alpha-x86_64 ls -l / /bin /usr/bin

- Environment: You may want to set `PATH` or other variables explicitly if your rootfs is minimal:

  ::

    docker run --rm -it -e PATH=/bin:/usr/bin openlinux:1.0.0-alpha-x86_64 /bin/sh

- Mounts (optional): Bind-mount a host directory for development or data:

  ::

    docker run --rm -it -v "$PWD":/work -w /work openlinux:1.0.0-alpha-x86_64 /bin/sh

Using a Dockerfile (FROM scratch)
---------------------------------

Instead of `docker import`, you can build an image from a Dockerfile using `FROM scratch`.
Docker will extract the tarball into the image at build time.

Example:

::

  # Dockerfile
  FROM scratch
  ADD openlinux-1.0.0-alpha-x86_64-rootfs.tar.gz /
  ENV PATH=/bin:/usr/bin
  CMD ["/bin/sh"]

Build and tag:

::

  cp build/x86_64/openlinux-1.0.0-alpha-x86_64-rootfs.tar.gz .
  docker build -t openlinux:1.0.0-alpha-x86_64 .

Run:

::

  docker run --rm -it openlinux:1.0.0-alpha-x86_64

Architecture and platform notes
-------------------------------

- Docker containers use the host kernel. Your rootfs userland must be compatible with the
  kernel ABI and the target architecture.
- Running different-architecture images on your host typically requires binfmt_misc and
  user-mode emulation (e.g., `qemu-user-static`). If you have cross-arch emulation set up,
  you can hint the desired platform:

  ::

    docker run --platform=linux/arm64 --rm -it openlinux:1.0.0-alpha-aarch64 /bin/sh

- On Apple Silicon (ARM64) hosts, prefer ARM64 images or enable cross-arch emulation to run x86_64 images.

Updating and rebuilding
-----------------------

Iterative workflow:

::

  # Rebuild libraries/binaries/sysroot
  make -j8

  # Rebuild the rootfs tarball
  make rootfs

  # Re-import with an updated tag (or overwrite the previous one)
  docker import build/<ARCH>/openlinux-<VERSION>-<ARCH>-rootfs.tar.gz openlinux:<VERSION>-<ARCH>

- Consider embedding a timestamp or git commit in the tag for traceability.

Troubleshooting
---------------

- Docker daemon not reachable:

  - Symptom: `docker` commands hang or error with connection/permission issues.
  - Fix: Ensure Docker is installed, running, and your user has permission to access the daemon.

- Missing shell or entrypoint:

  - Symptom: `docker run ... /bin/sh` fails with “file not found”.
  - Fix: Use an existing binary from your rootfs (check `/bin` and `/usr/bin`). If a shell
    is not present, choose a different entrypoint or add one to the sysroot.

- Import fails or image not found:

  - Symptom: `docker import` errors or subsequent `docker run` cannot find the tag.
  - Fix: Verify the tarball path, re-run `make rootfs`, and ensure you used a consistent tag.
    List local images with `docker images`.

- Architecture mismatch:

  - Symptom: Executable fails to run due to wrong architecture.
  - Fix: Use an image that matches your host’s architecture or enable cross-arch emulation
    (`--platform=...` with binfmt_misc/qemu-user-static).

- Minimal rootfs issues:

  - Symptom: Commands fail due to missing `/etc/*` files or minimal environment.
  - Fix: Set environment variables (`PATH`, `TERM`), mount necessary volumes, or extend the
    rootfs to include required tooling/configuration.

See also
--------

- Build system and artifacts: ``docs/build.rst``
- Boot process and kernel command line: ``docs/boot.rst``
- Running in virtualized hardware: ``docs/qemu.rst``
